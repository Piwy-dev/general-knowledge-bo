{
    "algebra": {
        "matrices": {
            "matrice échelonée": {
                "color": "0x3b8bc4",
                "title": "Matrice échelonée",
                "description": "Une matrice est dite échelonnée si le nombre de zéros précédant la première valeur non nulle d'une ligne augmente strictement ligne par ligne jusqu'à ce qu'il ne reste éventuellement plus que des zéros.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```0 | 1 | 2 | 3 | 4\n0 | 0 | 5 | 8 | 7\n0 | 0 | 0 | 9 | 10\n0 | 0 | 0 | 0 | 0\n0 | 0 | 0 | 0 | 0```"
                    }
                ]
            }, 
            "forme réduite de gauss-jordan": {
                "color": "0x3b8bc4",
                "title": "Forme réduite de Gauss-Jordan",
                "description": "Une matrice est dite en forme réduite de Gauss-Jordan si elle est échelonnée et si toutes les valeurs non nulles sont égales à 1.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```1 | 0 | 0 | 0 | 0\n0 | 1 | 0 | 0 | 0\n0 | 0 | 1 | 0 | 0\n0 | 0 | 0 | 1 | 0\n0 | 0 | 0 | 0 | 1```"
                    }
                ]
            },
            "matrice carrée": {
                "color": "0x3b8bc4",
                "title": "Matrice carrée",
                "description": "Une matrice est dite carrée si elle possède le même nombre de lignes et de colonnes.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```0 | 1 | 2\n3 | 4 | 5\n6 | 7 | 8```"
                    }
                ]
            },
            "produit matriciel": {
                "color": "0x3b8bc4",
                "title": "Produit matriciel",
                "description": "Le produit matriciel de deux matrices `A` et `B` est une matrice `C` telle que `C = AB`.",
                "fields": [{
                        "name": "Condition de résolution",
                        "value": "Le nombre de colonnes de la première matrice doit être égal au nombre de lignes de la deuxième matrice. \nSi `A` est une matrice de dimention `m x n` et `B` une matrice `n x k`, alors il est possible de réaliser le produit `AB` mais pas le produit `BA`."
                    }, {
                        "name": "Methode de résolution",
                        "value": "Pour chaque élément de la matrice résultat, on calcule la somme des produits des éléments de la ligne de la première matrice et de la colonne de la deuxième matrice. \nPour rendre cela plus facile on peut placer les matrices du produit de manière à ce que la matrice résultat se trouve à droite de la première matrice et en dessous de la seconde."
                    }, {
                        "name": "Exemple",
                        "value": "```          b  |  b  |  b \n          b  |  b  |  b\na | a    2ab | 2ab | 2ab  \na | a    2ab | 2ab | 2ab```"
                    }
                ]
            }
        }
    },
    "algorithmics": {
        "Général": {
            "Définition d'un algorithme": {
                "color": "0xebc034",
                "title": "Définition d'un algorithme",
                "description": "Un algorithme est l’idée derrière un programme. C’est une suite finie d’opérations élémentaires qui permet de résoudre un problème donné. \n- Un algorithme est indépendant du langage de programmation, du système d’exploitation et de la machine sur laquelle s’exécute le programme qui implémente l’algorithme. \n- Pour certains problèmes (même très courants et simples à énoncer), iln’existe pas d’algorithme exact et efficace. \n- Pour d’autres problèmes, il existe plusieurs algorithmes exacts (certains sont plus efficaces que d’autres).",
                "fields": [{
                        "name": "Propriétés d'un algorithme",
                        "value": "- Avoir une portée suffisamment large. \n- Etre exact : un algorithme doit donner le résultat exact attendu. \n- Etre fini : un algorithme doit se terminer après un nombre fini d’étapes. \n- Etre efficace : il doit se terminer en un temps raisonnable et utiliser une quantité raisonnable de mémoire."
                    }
                ]
            }
        },
        "Complexité caluclatoire": {
            "Complexité temporelle": {
                "color": "0xebc034",
                "title": "Complexité temporelle",
                "description": "La complexité temporelle d’un algorithme est le nombre d’opérations élémentaires effectuées par l’algorithme pour résoudre un problème de taille `n`. Cette donnée est importante car, si on connait le temps nécessaire pour une opération primitive, elle permet de déterminer la taille maximale du problème que l'on peut traiter sur un interval de temps donné.",
                "fields": [{
                        "name": "Notation",
                        "value": "La complexité temporelle d’un algorithme est notée `T(n)`  et représente donc le nombre d’opérations élémentaires effectuées par l’algorithme pour résoudre un problème de taille `n`."
                    }
                ]
            },
            "Complexité spaciale": {
                "color": "0xebc034",
                "title": "Complexité spaciale",
                "description": "La complexité spaciale d’un algorithme est la quantité de mémoire utilisée par l’algorithme pour résoudre un problème de taille `n`. Cette donnée est importante car, si on connait la quantité de mémoire disponible, elle permet de déterminer la taille maximale du problème que l'on peut traiter.",
                "fields": [{
                        "name": "Notation",
                        "value": "La complexité spaciale d’un algorithme est notée `S(n)` et représente donc la quantité de mémoire utilisée par l’algorithme pour résoudre un problème de taille `n`."
                    }
                ]
            }
        },
        "Types abstraits de données": {
            "Description générale des TAD": {
                "color": "0xebc034",
                "title": "Description générale des TAD",
                "description": "**Structure de données :** une organisation particulière des données d’un programme (int, str, list…). \n\nType abstrait de données (TAD) : une spécification abstraite d’une structure de données qui décrit : \n1. Ce qui peut être mémorisé dans le TAD, mais pas comment cette information est mémorisée (organisation dans la mémoire). \n2. Quelles opérations peuvent être effectuées sur le TAD, mais pas comment ces opérations doivent être effectuées."                
            },
            "TAD pile": {
                "color": "0xebc034",
                "title": "TAD pile",
                "description": "Le TAD pile est une collection d’éléments ordonnés selon le principe LIFO (Last In First Out). Il est possible d’ajouter un élément au sommet de la pile, de retirer l’élément au sommet de la pile et de savoir si la pile est vide ou non. \nLes TAD piles permentent d’implémenter des tableaux (souvent dynamiques) ou des listes chaînées. \n**Analogie :** une pile d’assiettes.",
                "fields": [{
                        "name": "Opérations principales",
                        "value": "- `push(x)` Ajoute l’élément `x` au sommet de la pile. \n- `pop()` Retire l’élément au sommet de la pile. \n- `isEmpty()` Retourne `vrai` si la pile est vide, `faux` sinon."
                    }, {
                        "name": "Exemple",
                        "value": "```p = [1, 2, 3]```"
                    }
                ]
            },
            "TAD file": {
                "color": "0xebc034",
                "title": "TAD file",
                "description": "Le TAD file est une collection d’éléments ordonnés selon le principe FIFO (First In First Out). Il est possible d’ajouter un élément à la fin de la file, de retirer l’élément au début de la file et de savoir si la file est vide ou non. \nLes TAD files permetent d’implémenter des tableaux (souvent dynamiques) circulaires ou des listes chaînées. \n**Analogie :** une file d’attente.",
                "fields": [{
                        "name": "Opérations principales",
                        "value": "- `enqueue(x)` Ajoute l’élément `x` à la fin de la file. \n- `dequeue()` Retire l’élément au début de la file. \n- `isEmpty()` Retourne `vrai` si la file est vide, `faux` sinon."
                    }, {
                        "name": "Exemple",
                        "value": "```f = [1, 2, 3]```"
                    }
                ]
            },
            "TAD liste": {
                "color": "0xebc034",
                "title": "TAD liste",
                "description": "Une Liste est un TAD qui décrit une collection d’éléments auxquels on accède via les méthodes `head()` (le premier élément) et `tail()` (une sous-liste). \nCe TAD à une implémentation [récursive](https://www.notion.so/Introduction-l-algorithmique-c23fafa64c8948f48a4594eeaf12699f?pvs=21). Pour accéder à un élement spécifique dans la liste, on va utliser une fonction dont le cas de base est une liste vide et l’appel récusif, lancé si l’élément ne correspond pas à la valeur actuelle, se fait sur la sous-liste."
            },
            "TAD dictionaire": {
                "color": "0xebc034",
                "title": "TAD dictionaire",
                "description": "Le TAD dictionaire est une collection d’entrées pour laquelle on accède à chaque entrée par une clé. Il contient donc des couples (clé, valeur). Il est à clés multiples si plusieurs entrées présentes sont référencées par la même clé et il est ordonné si un ordre est défini sur les clés.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```d = {\"a\": 1, \"b\": 2, \"c\": 3}```"
                    }
                ]
            }
        },
        "Arbre binaire de recherche": {
            "Description générale des ABR": {
                "color": "0xebc034",
                "title": "Description générale des ABR",
                "description": "Un arbre binaire de recherche (ABR) est une implémentation d’un TAD dictionaire qui respecte les propriétés suivantes : \n- Les noeuds de gauche sont plus petits que la racine \n- Les noeuds de droite sont plus grands que la racine \n- Les sous-arbres gauches et droits sont eux-mêmes des ABR",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```          8\n        /   \\\n       3     10\n      / \\      \\\n     1   6      14\n        / \\    /\n       4   7  13```"
                    }
                ]
            },
            "Parcours d'un ABR": {
                "color": "0xebc034",
                "title": "Parcours d’un ARB",
                "description": "Pour effectuer des actions dans un ABR, il est nécessaire de pouvoir le parcourir. Il existe différentes manière de parcourir un ABR, toutes sont récursives.",
                "fields": [{
                        "name": "Parcours préfixe",
                        "value": "Le parcours préfixe visite d’abords la racine puis les sous-arbres gauches et droits."
                    }, {
                        "name": "Parcours infixe",
                        "value": "Le parcours infixe visite d’abords le sous-arbre gauche puis la racine et enfin le sous-arbre droit."
                    }, {
                        "name": "Parcours postfixe",
                        "value": "Le parcours postfixe visite d’abords les sous-arbres gauches et droits puis la racine."
                    }, {
                        "name": "Parcours eulerien",
                        "value": "Les trois parcours réalisent en réalité tous le même trajet en commençant par la racine, et en visitant chaque neud 3 fois, mais en récupérant l’information du noeud à un passage différent à chaque fois. \nIl existe un parcous appelé parcours eurélien qui généralise ces trois parcours en un algorithme."
                    }
                ]
            },
            "Opérations dans un ABR": {
                "color": "0xebc034",
                "title": "Opérations dans un ARB",
                "fields": [
                    {
                        "name": "Insertion d’une clé",
                        "value": "Pour insérer une clé dans l’ARB, on va parcourrir l’arbre par la méthode préfixe, jusqu’à se qu’on se trouve à un endroit ou le noeud de gauche est plus petit ou églal à la clé et le noeud de droite plus grand. On doit alors insérer cette clé dans l’arbre par la même méthode que pour l’insersion dans une liste chaînée. "
                    },
                    {
                        "name": "Recherche d’une clé",
                        "value": "La recherche d’une clé dans un ARB dépend de sa hauteur et donc aussi son organisation.\n- Si l’arbre est équilibré sa hauteur `h ∈ Θ(log_2 n)`. La recherche se fait donc en `O(log_2 n)` (meilleur cas `Θ(1)`, pire cas `Θ(log_2 n)`).\n- Sinon sa hauteur `h ∈ Θ(n)`. La recherche se fait donc en `O(n)` (meilleur cas `Θ(1)`, pire cas `Θ(n)`)."
                    },
                    {
                        "name": "Supression d’une clé",
                        "value": "Pour la supression d’une clé on va d’abords rechecher cette clé dans l’arbre. Une fois trouvée, on la supprime aussi en suivant une méthode analogue aux listes chaînées mais il faut aussi faire attention de remonter les clés appartenant aux sous-arbres de la clé qu’on supprime qui ne seraient plus dans l’odre."
                    }
                ]
            },
            "Implémentation d'un ABR": {
                "color": "0xebc034",
                "title": "Implémentation d'un ABR",
                "description": "Dans la pratique les méthodes les plus courrante pour implémenter un ARB sont soit via une structure chaînée soit un tableau dynamique. Les deux méthodes ont leurs avantages et inconvénients.",
                "fields": [
                    {
                        "name": "Structure chaînée",
                        "value": "- Accès à n’importe quel noeud à partir de la racine en `O(n)`.\n- Complexité spatiale en `Θ(n)`."
                    },
                    {
                        "name": "Tableau dynamique",
                        "value": "- Accès à n’importe quel noeud en `Θ(1)` par un calcul d’indice dans le tableau.\n- La complexité spatiale peut être exponentielle dans le pire cas : `O(2^n)`, où `n` est le nombre de noeuds présents dans l’arbre. Si l’arbre est strictement complet, c’est-à-dire si tous les niveaux sont remplis, alors la complexité spatiale est en `Θ(n)`."
                    }
                ]
            }
        }
    },
    "electronics": {
        "fonctions booléennes": {
            "not": {
                "color": "0x5834eb",
                "title": "Not",
                "description": "La porte logique **NOT** retourne l'inverse de son entrée.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nin | out\n0  | 1\n1  | 0\n```"
                    }
                ],
                "thumbnail": { 
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097089814840496188/not.png"
                }
            },
            "and": {
                "color": "0x5834eb",
                "title": "And",
                "description": "La porte logique **AND** retourne 1 si les deux entrées sont à 1, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097117357576568883/and.png"
                }
            },
            "or": {
                "color": "0x5834eb",
                "title": "Or",
                "description": "La porte logique **OR** retourne 1 si au moins une des deux entrées est à 1, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097266856865321080/or.png"
                }
            },
            "nand": {
                "color": "0x5834eb",
                "title": "Nand",
                "description": "La porte logique **NAND** retourne 1 si au moins une des deux entrées est à 0, et 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267029477707816/nand.png"
                }
            },
            "nor": {
                "color": "0x5834eb",
                "title": "Nor",
                "description": "La porte logique **NOR** retourne 1 si les deux entrées sont 0, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267140735815771/nor.png"
                }
            },
            "xor": {
                "color": "0x5834eb",
                "title": "Xor",
                "description": "La porte logique **XOR** retourne 1 si les deux entrées sont différentes, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267300492640256/xor.png"
                }
            },
            "xnor": {
                "color": "0x5834eb",
                "title": "Xnor",
                "description": "La porte logique **XNOR** retourne 1 si les deux entrées sont identiques, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097089814840496188/xnor.png"
                }
            },
            "mux": {
                "color": "0x5834eb",
                "title": "Mux",
                "description": "La porte logique **MUX** (Multiplexer) permet de choisir entre deux entrées selon la valeur d'une troisième entrée (sel).",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | sel | out\n0 | 0 | 0 | 0\n0 | 0 | 1 | 0\n0 | 1 | 0 | 0\n0 | 1 | 1 | 1\n1 | 0 | 0 | 1\n1 | 0 | 1 | 0\n1 | 1 | 0 | 1\n1 | 1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267398266073168/mux.png"
                }
            },
            "dmux": {
                "color": "0x5834eb",
                "title": "Dmux",
                "description": "La porte logique **DMUX** (Demultiplexer) retourne les valeurs de A et B selon la valeur de in et sel.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nin | sel | A | B\n0 | 0 | 0 | 0\n0 | 1 | 0 | 0\n1 | 0 | 1 | 0\n1 | 1 | 0 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267480638005371/dmux.png"
                }
            }
        },
        "language d'assemblage": {
            "instructions de type A": {
                "color": "0xd99241",
                "title": "Instructions de type A",
                "description": "Les instructions de type A (A = adresse) permettent de charger des information de 15 bits (avec le bits de poid fort mit à 0 pour faire 16 bits en tout) dans le registre A. Elles permetent aussi d’accéder à l’information qui se trouve en mémoire à l’adresse spécifiée dans le registre A.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@12 // Charge la valeur 12 dans A et permet d'accéder là l'information contenue dans la mémoire à l'adresse 12.\n```"
                    }
                ]
            },
            "instructions de type C": {
                "color": "0xd99241",
                "title": "Instructions de type C",
                "description": "Les instructions de type C (C = calculer) permettent d’effectuer toutes les autres opérations permisent par l’ALU. Elles ont donc plusieurs fonctionalités différentes. Il y a deux sortes d’instructions  différentes : Les instructions d’accès et @."
            },
            "saut non-conditionel": {
                "color": "0xd99241",
                "title": "Saut non-conditionel",
                "description": "L’instruction **0;JMP**© permet de faire un saut non-conditionel (sera toujours effectué si l’instruction est lue) vers l’adresse indiquée.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n(DEBUT) // Début de la boucle\n@x\nM=M+1 // Ajoute 1 à la valeur de x\n0;JMP // Saut vers le début de la boucle\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\nwhile True:\n    x += 1\n```"
                    }
                ]
            },
            "saut conditionel": {
                "color": "0xd99241",
                "title": "Saut conditionel",
                "description": "Il existe plusieurs instructions qui permettent d’effectuer un saut seulement si la condition attendue est respectée. La condition peut être imposée sur n’importe quelle variable exitante. Dans les exemple ci-dessus c’est le registre `D` qui est utilisé :\n\n1. `D;JEQ` (Jump if EQual to 0) → Saute si la variable vaut 0. (`D == 0`)\n2. `D;JNE` (Jump if Not Equal to 0) → Saute si la variable est différente de 0. (`D != 0`)\n3. `D;JGT` (Jump if Greater Than 0) → Saute si la variable est strictement positive. (`D > 0`)\n4. `D;JLT` (Jump if Lower Than 0) → Saute si la variable est strictement négative. (`D < 0`)\n5. `D;JGE` (Jump if Greater than or Equal to 0) → Saute si la variable est positive. (`D >= 0`)\n6. `D;JLE` (Jump if Lower than or Equal to 0) → Saute si la variable est négative. (`D <= 0`)",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@x\nD=M // Assigne la valeur de x à D\n\n@COND\nD;JGT // Saute si x > 0\n@x\nM=1 // Assigne la valeur 1 à x\n@FIN\n0;JMP // Saute à le fin pour ne pas effectuer le rest du code\n(COND)\n\n@x\nM=-1 // Assigne la valeur -1 à x\n(FIN)\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nif x > 0:\n    x = 1\nelse:\n    x = -1\n```"
                    }
                ]
            },
            "boucles": {
                "color": "0xd99241",
                "title": "Boucles",
                "description": "Les boucles peuvent être implémentée en utilisant des instruction de saut.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@x\nM=1 // Assigne la valeur 1 à x\n@n\nM=1 // Assigne la valeur 1 à n\n\n(DBOUCLE) // Début de la boucle\n@10\nD=A // Assigne la valeur 10 à D\n@n\nD=M-D // Assigne la valeur de (n - 10) à D -> Si n >= 10 (inverse de la condition de la boucle), D >= 0\n@FBOUCLE\nD;JGE // Saute vers la fin si D >= 0 (condition de la boucle n'est plus respectée)\n@x\nD=M // Assigne la valeur de x à D\n@x\nM=D+M // Assigne la valeur de (x + x) à x\n@n\nM=M+1 // Ajoute 1 à la valeur de n\n@DBOUCLE\n0;JMP // Saute vers le début de la boucle\n(FBOUCLE) // Fin de la boucle\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 1\nn = 1\nwhile n < 10:\n    x += x\n    n += 1\n```"
                    }
                ]
            },
            "break": {
                "color": "0xd99241",
                "title": "Break",
                "description": "Il possible d’impléménter l’instuction `break` grâce aux sauts, en language assembleur.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n// Assigne la valeur 0 à x\n@x\nM=0\n\n// Assigne la valeur 0 à y\n@y\nM=0\n\n(DBOUCLE)\n// Saute vers la fin si x != 0\n@x\nD=M\n@FBOUCLE\nD;JNE\n\n// Ajoute 1 à la valeur de y\n@y\nM=M+1\n\n// Saute vers le début si y != 2\n@2\nD=A\n@y\nD=M-D // y-2 -> si y != 2, D != 0\n@DBOUCLE\nD;DNE\n\n// Termine la boucle si y == 2 -> break\n@FBOUCLE\n0;JMP\n(FBOUCLE)\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\ny = 0\nwhile x==0: # sera toujours vrai\n    y += 1\n    if y == 2:\n        break # y vaudra 2 à la fin\n```"
                    }
                ]
            },
            "continue": {
                "color": "0xd99241",
                "title": "Continue",
                "description": "Il possible d’impléménter l’instuction `continue` grâce aux sauts, en language assembleur.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n// Assigne la valeur 0 à x\n@x\nM=0\n\n(DBOUCLE)\n// Retourne au début de la boucle -> continue\n@DBOUCLE\n0;JMP\n\n// Ajoute 1 à la valeur de x\n@x\nM=M+1```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\nwhile True:\n   continue # La boucle infie va continuer sans rien faire\n   x += 1 # Cette ligne ne sera jamais lue\n```"
                    }
                ]
            }
        }
    }
}