{
    "algebra": {
        "Matrices": {
            "Matrice échelonée": {
                "color": "0x3b8bc4",
                "title": "Matrice échelonée",
                "description": "Une matrice est dite échelonnée si le nombre de zéros précédant la première valeur non nulle d'une ligne augmente strictement ligne par ligne jusqu'à ce qu'il ne reste éventuellement plus que des zéros.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```0 | 1 | 2 | 3 | 4\n0 | 0 | 5 | 8 | 7\n0 | 0 | 0 | 9 | 10\n0 | 0 | 0 | 0 | 0\n0 | 0 | 0 | 0 | 0```"
                    }
                ]
            }, 
            "Forme réduite de gauss-jordan": {
                "color": "0x3b8bc4",
                "title": "Forme réduite de Gauss-Jordan",
                "description": "Une matrice est dite en forme réduite de Gauss-Jordan si elle est échelonnée et si toutes les valeurs non nulles sont égales à 1.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```1 | 0 | 0 | 0 | 0\n0 | 1 | 0 | 0 | 0\n0 | 0 | 1 | 0 | 0\n0 | 0 | 0 | 1 | 0\n0 | 0 | 0 | 0 | 1```"
                    }
                ]
            },
            "Matrice carrée": {
                "color": "0x3b8bc4",
                "title": "Matrice carrée",
                "description": "Une matrice est dite carrée si elle possède le même nombre de lignes et de colonnes.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```0 | 1 | 2\n3 | 4 | 5\n6 | 7 | 8```"
                    }
                ]
            },
            "Produit matriciel": {
                "color": "0x3b8bc4",
                "title": "Produit matriciel",
                "description": "Le produit matriciel de deux matrices `A` et `B` est une matrice `C` telle que `C = AB`.",
                "fields": [{
                        "name": "Condition de résolution",
                        "value": "Le nombre de colonnes de la première matrice doit être égal au nombre de lignes de la deuxième matrice. \nSi `A` est une matrice de dimention `m x n` et `B` une matrice `n x k`, alors il est possible de réaliser le produit `AB` mais pas le produit `BA`."
                    }, {
                        "name": "Methode de résolution",
                        "value": "Pour chaque élément de la matrice résultat, on calcule la somme des produits des éléments de la ligne de la première matrice et de la colonne de la deuxième matrice. \nPour rendre cela plus facile on peut placer les matrices du produit de manière à ce que la matrice résultat se trouve à droite de la première matrice et en dessous de la seconde."
                    }, {
                        "name": "Exemple",
                        "value": "```          b  |  b  |  b \n          b  |  b  |  b\na | a    2ab | 2ab | 2ab  \na | a    2ab | 2ab | 2ab```"
                    }
                ]
            }
        }
    },
    "algorithmics": {
        "Général": {
            "Définition d'un algorithme": {
                "color": "0xebc034",
                "title": "Définition d'un algorithme",
                "description": "Un algorithme est l’idée derrière un programme. C’est une suite finie d’opérations élémentaires qui permet de résoudre un problème donné. \n- Un algorithme est indépendant du langage de programmation, du système d’exploitation et de la machine sur laquelle s’exécute le programme qui implémente l’algorithme. \n- Pour certains problèmes (même très courants et simples à énoncer), iln’existe pas d’algorithme exact et efficace. \n- Pour d’autres problèmes, il existe plusieurs algorithmes exacts (certains sont plus efficaces que d’autres).",
                "fields": [{
                        "name": "Propriétés d'un algorithme",
                        "value": "- Avoir une portée suffisamment large. \n- Etre exact : un algorithme doit donner le résultat exact attendu. \n- Etre fini : un algorithme doit se terminer après un nombre fini d’étapes. \n- Etre efficace : il doit se terminer en un temps raisonnable et utiliser une quantité raisonnable de mémoire."
                    }
                ]
            }
        },
        "Complexité caluclatoire": {
            "Complexité temporelle": {
                "color": "0xebc034",
                "title": "Complexité temporelle",
                "description": "La complexité temporelle d’un algorithme, notée `T(n)`,  représente le nombre d’opérations primitives effectuées par l’algorithme pour résoudre un problème de taille `n`. \nCette donnée est importante car si on connait le temps nécessaire pour une opération primitive, elle permet de déterminer la taille maximale du problème que l'on peut traiter sur un intervalle de temps donné."
            },
            "Complexité spaciale": {
                "color": "0xebc034",
                "title": "Complexité spaciale",
                "description": "La complexité spatiale d’un algorithme, notée `S(n)`, représente la quantité de mémoire utilisée par l’algorithme pour résoudre un problème de taille `n`. \nCette donnée est importante car si on connait la quantité de mémoire disponible, elle permet de déterminer la taille maximale du problème que l'on peut traiter."
            }
        },
        "Types Abstraits de Données": {
            "Généralités": {
                "color": "0x3b8bc4",
                "title": "Types abstraits de données",
                "description": "Un type abstrait de données (TAD) est une spécification abstraite d’une structure de données qui décrit : \n1. Ce qui peut être mémorisé dans le TAD, mais pas comment cette information est mémorisée (organisation dans la mémoire). \n2. Quelles opérations peuvent être effectuées sur le TAD, mais pas comment ces opérations doivent être effectuées. \n\nUne structure de données : une organisation particulière des données d’un programme (int, str, list…)"
            },
            "TAD Pile": {
                "color": "0x3b8bc4",
                "title": "Pile",
                "description": "Une pile (Stack) est une collection d’éléments qui peuvent être ajoutés ou retirés selon le principe LIFO (Last In First Out) : \n- Le premier objet à pouvoir être retiré (*pop*) est le dernier qui a été inséré (*push*). \n- On ne peut pas retirer d’objet si la pile est vide.",
                "fields": [{
                        "name": "Analogie",
                        "value": "Une pile d’assiettes."
                    }, {
                        "name": "Opérations principales",
                        "value": "- `push(e)` : ajoute l'élément `e` au sommet de la pile. \n- `pop()` : retire et renvoie l’élément au sommet de la pile. \n- `is_empty()` : renvoie `True` si la pile est vide, `False` sinon."
                    }, {
                        "name": "Méthodes d'implémentation",
                        "value": "- Listes chaînées \n- Tableaux dynamiques"
                    }, {
                        "name": "Exemple",
                        "value": "```py\npile = Stack() \npile.push(1) \npile.push(2) \n\nprint(pile.pop())\n>>> 2\nprint(pile.pop()) \n>>> 1```"
                    }
                ]
            },
            "TAD File": {
                "color": "0x3b8bc4",
                "title": "File",
                "description": "Une file (Queue) est une collection d’éléments qui peuvent être ajoutés ou retirés selon le principe FIFO (First In First Out) : \n- Le premier objet à pouvoir être retiré est le plus ancien à avoir été inséré et qui n’a pas encore été retiré. \n- On ne peut retirer aucun objet si la file est vide.",
                "fields": [{
                        "name": "Analogie",
                        "value": "Une file d’attente."
                    }, {
                        "name": "Opérations principales",
                        "value": "- `enqueue(e)` : ajoute l'élément `e` à la fin de la file. \n- `dequeue()` : retire et renvoie l’élément au début de la file. \n- `is_empty()` : renvoie `True` si la file est vide, `False` sinon."
                    }, {
                        "name": "Méthodes d'implémentation",
                        "value": "- Listes chaînées \n- Tableaux dynamiques circulaires"
                    }, {
                        "name": "Exemple",
                        "value": "```py\nfile = Queue() \nfile.enqueue(1) \nfile.enqueue(2) \n\nprint(file.dequeue())\n>>> 1\nprint(file.dequeue()) \n>>> 2```"
                    }
                ]
            },
            "TAD Liste": {
                "color": "0x3b8bc4",
                "title": "Liste",
                "description": "Une Liste est un TAD qui décrit une collection d’éléments auxquels on accède via les méthodes `head()` (le premier élément) et `tail()` (une sous-liste). \n\nCe TAD à une implémentation récursive. Pour accéder à un élément spécifique dans la liste, on va utiliser une fonction dont le cas de base est une liste vide et l’appel récursif éventuel se fait sur la sous-liste.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```py\nl = List() # creation d'une liste vide \nl = l.concat(1) # ajoute 1 en tête de la liste \nl = l.concat(2) # ajoute 2 en tête de la liste \nprint(l.head()) \n>>> 2 \nprint(l) \n>>> \"[2[1[]]]\" \nprint(l.tail()) \n>>> \"[1[]]\"```"
                    }
                ]
            },
            "TAD Dictionnaire": {
                "color": "0x3b8bc4",
                "title": "Dictionnaire",
                "description": "Le TAD dictionnaire est une collection d’entrées pour laquelle on accède à chaque entrée par une clé. Il contient donc des couples (clé, valeur).",
                "fields": [{
                        "name": "Propriété additionnelle possibles",
                        "value": "- **Clés multiples** : plusieurs entrées sont référencées par la même clé \n- **Ordonné** : un ordre est défini sur les clés."
                    }
                ]
            },
            "TAD Arbre": {
                "color": "0x3b8bc4",
                "title": "Arbre",
                "description": "Le TAD arbre permet de représenter une structure hiérarchique (table des matières, système de fichiers…). C’est un type abstrait récursif composé de différents noeuds (il peut aussi être vide). Un noeud se trouve à la racine et les autres dans les sous-arbres. \n\nUn arbre est binaire si pour chaque noeud il y a au maximum deux sous arbres (gauche et droit).",
                "fields": [{
                        "name": "Exemple",
                        "value": "```      a       \n    /   \\    \n   b     c   \n  / \\   / \\ \n d   e f   g\n```"
                    }
                ]
            }
        },
        "Arbre Binaire de Recherche": {
            "Généralités": {
                "color": "0xf0a573",
                "title": "Arbres binaires de recherche",
                "description": "Un arbre binaire de recherche (ABR) est une implémentation d’un TAD dictionnaire dans sous forme d’arbre binaire. Dans un ABR, pour chaque noeud, l’élément qui se trouve à gauche de celui-ci doit-être plus petit et l’élément à droite doit être plus grand."
            }, 
            "Parcours": {
                "color": "0xf0a573",
                "title": "Parcours d'un ABR",
                "description": "Il y a trois opérations possible dans un ABR : l’insertion, la suppression ou la recherche d’une clé. \nPour effectuer ces actions, il est nécessaire de parcourir l’arbre. Il existe différentes manière de parcourir un ABR, toutes sont récursives.",
                "fields": [{
                        "name": "Parcours infixe",
                        "value": "On parcourt l’arbre en commençant par le sous-arbre gauche, puis la racine et enfin le sous-arbre droit."
                    }, {
                        "name": "Parcours préfixe",
                        "value": "On parcourt l’arbre en commençant par la racine, puis le sous-arbre gauche et enfin le sous-arbre droit."
                    }, {
                        "name": "Parcours postfixe",
                        "value": "On parcourt l’arbre en commençant par le sous-arbre gauche, puis le sous-arbre droit et enfin la racine."
                    }, {
                        "name": "Exemple",
                        "value": "```       0       \n     /   \\    \n   -3     6   \n   / \\   / \\ \n -7  -1 4   9\n``` \nParcours infixe: ```-7 -3 -1 0 4 6 9``` \nParcours préfixe: ```0 -3 -7 -1 6 4 9``` \nParcours postfixe: ```-7 -1 -3 4 9 6 0```"
                    }
                ]
            },
            "Opérations": {
                "color": "0xf0a573",
                "title": "Opérations sur un ABR",
                "fields": [{
                    "name": "Insertion d'une clé",
                    "value": "Pour insérer une clé dans l’ABR, on va parcourir l’arbre par la méthode préfixe, jusqu’à se qu’on se trouve à un endroit ou le noeud de gauche est plus petit ou égal à la clé et le noeud de droite plus grand. On doit alors insérer cette clé dans l’arbre par la même méthode que pour l’insertion dans une liste chaînée."
                }, {
                    "name": "Recherche d'une clé",
                    "value": "La recherche d’une clé dans un ABR dépend de sa hauteur `h`, et celle si dépend de si l’arbre est équilibré ou non. \n- Arbre équilibré : `h ∈ Θ(log_2 n)` → Recherche en `O(log_2 n)` (meilleur cas `Θ(1)`, pire cas $Θ(log_2 n)$). \n- Arbre déséquilibré : `h ∈ Θ(n)` → Recherche en `O(n)` (meilleur cas `Θ(1)`, pire cas `Θ(n)`)."
                }, {
                    "name": "Suppression d'une clé",
                    "value": "Pour la suppression d’une clé on va d’abords rechercher cette clé dans l’arbre. Une fois trouvée, on la supprime en suivant une méthode analogue aux listes chaînées mais il faut aussi faire attention de remonter les clés appartenant aux sous-arbres de la clé qu’on supprime qui ne seraient plus dans l’ordre."
                }]
            },
            "Implémentation": {
                "color": "0xf0a573",
                "title": "Implémentation d'un ABR",
                "description": "Un ABR peut être implémenté de deux manières différentes : \n\n**Liste chaînée** \nChaque noeud est représenté par un objet contenant la clé, la valeur et les sous-arbres gauche et droit. \n- Accès à n’importe quel noeud à partir de la racine en `O(n)`. \n- Complexité spatiale en `Θ(n)`. \n\n**Tableau dynamique** \nChaque noeud est représenté par un objet contenant la clé, la valeur et l’indice des sous-arbres gauche et droit dans le tableau. \n- Accès à n’importe quel noeud en `Θ(1)` par un calcul d’indice dans le tableau. \n- La complexité spatiale peut être exponentielle dans le pire cas : `O(2^n)`, où `n` est le nombre de noeuds présents dans l’arbre. Si l’arbre est strictement complet, c’est-à-dire si tous les niveaux sont remplis, alors la complexité spatiale est en `Θ(n)`."
            }
        },
        "Algorithmes de tri": {
            "Tri à bulles": {
                "color": "0xd573f0",
                "title": "Tri à bulles",
                "description": "Inverser toute paire d’éléments adjacents qui sont désordonnés. Un plus grand élément est comme une bulle remontant vers la fin, et un plus petit élément une bulle descendant vers le début.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n^2)` \n    - `Theta(n^2)` comparaisons \n     - `O(n^2)` échanges \n- Stable \n- En place : espace additionnel `Theta(1)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef bubble_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(len(l) - 1, 0, -1): \n        for j in range(1, i+1): \n            if l[j-1] > l[j]: \n                l[j-1], l[j] = l[j], l[j-1] \n    return l\n```"
                }, {
                    "name": "Variante pour le rendre adaptatif",
                    "value": "On ajoute une vérification qui coupe la boucle si il n’y a pas eu d’échange lors de cette itération (et donc que la liste est déjà triée). \n- Complexité temporelle globale : `O(n^2)` \n- `O(n^2)` comparaisons \n- `O(n^2)` échanges"
                }, {
                    "name": "Code",
                    "value": "```py\ndef bubble_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(len(l) - 1, 0, -1): \n        swap = False \n        for j in range(1, i+1): \n            if l[j-1] > l[j]: \n                l[j-1], l[j] = l[j], l[j-1] \n                swap = True \n        if not swap: \n            break \n    return l\n```"
                }]
            },
            "Tri par sélection": {
                "color": "0xd573f0",
                "title": "Tri par sélection",
                "description": "Sélectionner de façon répétée le plus petit élément restant et le mettre au début.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n^2)` \n    - `Theta(n^2)` comparaisons \n    - `Theta(n)` échanges → marginalement interessant si on veut minimiser les échanges. Ò\n- En place : espace additionnel `Theta(1)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef selection_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(len(l)): \n        min_index = i \n        for j in range(i+1, len(l)): \n            if l[min_index] > l[j]: \n                min_index = j \n        l[i], l[min_index] = l[min_index], l[i] \n    return l\n```"
                }]
            },
            "Tri par insertion": {
                "color": "0xd573f0",
                "title": "Tri par insertion",
                "description": "Insérer de façon répétée chaque élément dans la partie déjà triée de la liste.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `O(n^2)` \n    - `O(n^2)` comparaisons \n    - `O(n^2)` échanges \n- Stable \n- En place : espace additionnel `Theta(1)` \n- Adaptatif"
                }, {
                    "name": "Code",
                    "value": "```py\ndef insertion_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(1, len(l)): \n        j = i \n        while j > 0 and l[j-1] > l[j]: \n            l[j-1], l[j] = l[j], l[j-1] \n            j -= 1 \n    return l\n```"
                }]
            },
            "Tri fusion": {
                "color": "0xd573f0",
                "title": "Tri fusion",
                "description": "Diviser la liste en deux sous-listes de taille égale, trier chacune des sous-listes, puis fusionner les deux sous-listes triées en une seule liste triée. La première étape est récursive, le cas de base étant une liste de taille 0 ou 1 -> forcément triée.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n log n)` \n- Stable \n- En place : espace additionnel `Theta(n)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef merge_sort(l: list) -> list: \n    \"\"\" \n    Retourne la liste `l` triée par ordre croissant. \n    \"\"\"\n    def merge(l1: list, l2:list) -> list:\n        \"\"\" \n        Fusionne deux sous tableaux `l1` et `l2` triés.\n        \"\"\"\n        res = []\n        while len(l1) != 0 and len(l2) != 0:\n            if l1[0] <= l2[0]:\n                res.append(l1[0])\n                l1.pop(0)\n            else:\n                res.append(l2[0])\n                l2.pop(0)\n        while len(l1) != 0:\n            res.append(l1[0])\n            l1.pop(0)\n        while len(l2) != 0:\n            res.append(l2[0])\n            l2.pop(0)\n        return res\n    n = len(l)\n    if n == 1:\n        return l\n    return merge(merge_sort(l[:n//2]), merge_sort(l[n//2:]))\n```"
                }]
            },
            "Tri linéaire": {
                "color": "0xd573f0",
                "title": "Tri linéaire",
                "description": "Le tri linéaire est un tri qui s’effectue en temps linéaire. Il est possible de trier une liste en temps linéaire si on sait que les éléments de la liste sont des entiers compris entre 0 et `n` (ou `n-1`).",
                "fields": [{
                    "name": "Principe",
                    "value": "On va créer une liste de taille `n` remplie de 0. On va ensuite parcourir la liste à trier et incrémenter la valeur de la liste aux indices correspondant aux valeurs de la liste à trier. On va ensuite parcourir la liste de comptage et ajouter à la liste à trier autant de fois la valeur de l’indice que la valeur de l’indice. \n\nExemple : \n\n`[2, 5, 3, 0, 2, 3, 0, 3]` \n\n`[2, 0, 2, 1, 0, 1, 3, 0, 0, 0]` \n\n`[0, 0, 2, 2, 3, 3, 3, 5]`"
                }, {
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n)` \n- Stable \n- En place : espace additionnel `Theta(n)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef counting_sort(l: list) -> list: \n    \"\"\" \n    Retourne la liste `l` triée par ordre croissant. \n    \"\"\"\n    n = len(l)\n    res = [0] * n\n    for i in range(n):\n        res[l[i]] += 1\n    j = 0\n    for i in range(n):\n        while res[i] != 0:\n            l[j] = i\n            j += 1\n            res[i] -= 1\n    return l\n```"
                }]
            }
        }
    },
    "electronics": {
        "Fonctions booléennes": {
            "Not": {
                "color": "0x5834eb",
                "title": "Not",
                "description": "La porte logique **NOT** retourne l'inverse de son entrée.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nin | out\n0  | 1\n1  | 0\n```"
                    }
                ],
                "thumbnail": { 
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097089814840496188/not.png"
                }
            },
            "And": {
                "color": "0x5834eb",
                "title": "And",
                "description": "La porte logique **AND** retourne 1 si les deux entrées sont à 1, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097117357576568883/and.png"
                }
            },
            "Or": {
                "color": "0x5834eb",
                "title": "Or",
                "description": "La porte logique **OR** retourne 1 si au moins une des deux entrées est à 1, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097266856865321080/or.png"
                }
            },
            "Nand": {
                "color": "0x5834eb",
                "title": "Nand",
                "description": "La porte logique **NAND** retourne 1 si au moins une des deux entrées est à 0, et 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267029477707816/nand.png"
                }
            },
            "Nor": {
                "color": "0x5834eb",
                "title": "Nor",
                "description": "La porte logique **NOR** retourne 1 si les deux entrées sont 0, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267140735815771/nor.png"
                }
            },
            "Xor": {
                "color": "0x5834eb",
                "title": "Xor",
                "description": "La porte logique **XOR** retourne 1 si les deux entrées sont différentes, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267300492640256/xor.png"
                }
            },
            "Xnor": {
                "color": "0x5834eb",
                "title": "Xnor",
                "description": "La porte logique **XNOR** retourne 1 si les deux entrées sont identiques, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097089814840496188/xnor.png"
                }
            },
            "Mux": {
                "color": "0x5834eb",
                "title": "Mux",
                "description": "La porte logique **MUX** (Multiplexer) permet de choisir entre deux entrées selon la valeur d'une troisième entrée (sel).",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | sel | out\n0 | 0 | 0 | 0\n0 | 0 | 1 | 0\n0 | 1 | 0 | 0\n0 | 1 | 1 | 1\n1 | 0 | 0 | 1\n1 | 0 | 1 | 0\n1 | 1 | 0 | 1\n1 | 1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267398266073168/mux.png"
                }
            },
            "Dmux": {
                "color": "0x5834eb",
                "title": "Dmux",
                "description": "La porte logique **DMUX** (Demultiplexer) retourne les valeurs de A et B selon la valeur de in et sel.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nin | sel | A | B\n0 | 0 | 0 | 0\n0 | 1 | 0 | 0\n1 | 0 | 1 | 0\n1 | 1 | 0 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267480638005371/dmux.png"
                }
            }
        },
        "Language d'assemblage": {
            "Instructions de type A": {
                "color": "0xd99241",
                "title": "Instructions de type A",
                "description": "Les instructions de type A (A = adresse) permettent de charger des information de 15 bits (avec le bits de poid fort mit à 0 pour faire 16 bits en tout) dans le registre A. Elles permetent aussi d’accéder à l’information qui se trouve en mémoire à l’adresse spécifiée dans le registre A.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@12 // Charge la valeur 12 dans A et permet d'accéder là l'information contenue dans la mémoire à l'adresse 12.\n```"
                    }
                ]
            },
            "Instructions de type C": {
                "color": "0xd99241",
                "title": "Instructions de type C",
                "description": "Les instructions de type C (C = calculer) permettent d’effectuer toutes les autres opérations permisent par l’ALU. Elles ont donc plusieurs fonctionalités différentes. Il y a deux sortes d’instructions  différentes : Les instructions d’accès et @."
            },
            "Saut non-conditionel": {
                "color": "0xd99241",
                "title": "Saut non-conditionel",
                "description": "L’instruction **0;JMP**© permet de faire un saut non-conditionel (sera toujours effectué si l’instruction est lue) vers l’adresse indiquée.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n(DEBUT) // Début de la boucle\n@x\nM=M+1 // Ajoute 1 à la valeur de x\n0;JMP // Saut vers le début de la boucle\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\nwhile True:\n    x += 1\n```"
                    }
                ]
            },
            "Saut conditionel": {
                "color": "0xd99241",
                "title": "Saut conditionel",
                "description": "Il existe plusieurs instructions qui permettent d’effectuer un saut seulement si la condition attendue est respectée. La condition peut être imposée sur n’importe quelle variable exitante. Dans les exemple ci-dessus c’est le registre `D` qui est utilisé :\n\n1. `D;JEQ` (Jump if EQual to 0) → Saute si la variable vaut 0. (`D == 0`)\n2. `D;JNE` (Jump if Not Equal to 0) → Saute si la variable est différente de 0. (`D != 0`)\n3. `D;JGT` (Jump if Greater Than 0) → Saute si la variable est strictement positive. (`D > 0`)\n4. `D;JLT` (Jump if Lower Than 0) → Saute si la variable est strictement négative. (`D < 0`)\n5. `D;JGE` (Jump if Greater than or Equal to 0) → Saute si la variable est positive. (`D >= 0`)\n6. `D;JLE` (Jump if Lower than or Equal to 0) → Saute si la variable est négative. (`D <= 0`)",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@x\nD=M // Assigne la valeur de x à D\n\n@COND\nD;JGT // Saute si x > 0\n@x\nM=1 // Assigne la valeur 1 à x\n@FIN\n0;JMP // Saute à le fin pour ne pas effectuer le rest du code\n(COND)\n\n@x\nM=-1 // Assigne la valeur -1 à x\n(FIN)\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nif x > 0:\n    x = 1\nelse:\n    x = -1\n```"
                    }
                ]
            },
            "Boucles": {
                "color": "0xd99241",
                "title": "Boucles",
                "description": "Les boucles peuvent être implémentée en utilisant des instruction de saut.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@x\nM=1 // Assigne la valeur 1 à x\n@n\nM=1 // Assigne la valeur 1 à n\n\n(DBOUCLE) // Début de la boucle\n@10\nD=A // Assigne la valeur 10 à D\n@n\nD=M-D // Assigne la valeur de (n - 10) à D -> Si n >= 10 (inverse de la condition de la boucle), D >= 0\n@FBOUCLE\nD;JGE // Saute vers la fin si D >= 0 (condition de la boucle n'est plus respectée)\n@x\nD=M // Assigne la valeur de x à D\n@x\nM=D+M // Assigne la valeur de (x + x) à x\n@n\nM=M+1 // Ajoute 1 à la valeur de n\n@DBOUCLE\n0;JMP // Saute vers le début de la boucle\n(FBOUCLE) // Fin de la boucle\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 1\nn = 1\nwhile n < 10:\n    x += x\n    n += 1\n```"
                    }
                ]
            },
            "Break": {
                "color": "0xd99241",
                "title": "Break",
                "description": "Il possible d’impléménter l’instuction `break` grâce aux sauts, en language assembleur.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n// Assigne la valeur 0 à x\n@x\nM=0\n\n// Assigne la valeur 0 à y\n@y\nM=0\n\n(DBOUCLE)\n// Saute vers la fin si x != 0\n@x\nD=M\n@FBOUCLE\nD;JNE\n\n// Ajoute 1 à la valeur de y\n@y\nM=M+1\n\n// Saute vers le début si y != 2\n@2\nD=A\n@y\nD=M-D // y-2 -> si y != 2, D != 0\n@DBOUCLE\nD;DNE\n\n// Termine la boucle si y == 2 -> break\n@FBOUCLE\n0;JMP\n(FBOUCLE)\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\ny = 0\nwhile x==0: # sera toujours vrai\n    y += 1\n    if y == 2:\n        break # y vaudra 2 à la fin\n```"
                    }
                ]
            },
            "Continue": {
                "color": "0xd99241",
                "title": "Continue",
                "description": "Il possible d’impléménter l’instuction `continue` grâce aux sauts, en language assembleur.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n// Assigne la valeur 0 à x\n@x\nM=0\n\n(DBOUCLE)\n// Retourne au début de la boucle -> continue\n@DBOUCLE\n0;JMP\n\n// Ajoute 1 à la valeur de x\n@x\nM=M+1```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\nwhile True:\n   continue # La boucle infie va continuer sans rien faire\n   x += 1 # Cette ligne ne sera jamais lue\n```"
                    }
                ]
            }
        }
    },
    "marketing" : {
        "Segmentation" : {
            "Macro-segmentation" : {
                "color": "0xdba251",
                "title": "Macro-segmentation",
                "description": "La macro-segmentation segmente le marché en fonction de trois critères : \n1. Les **besoins** auxquels je réponds (quoi), \n2. Les groupes de **clients** concernés par ces besoins (qui) \n3. Les **solutions** technologiques existante capables de répondre à ces besoins (comment).",
                "fields": [{
                        "name": "Produit marché",
                        "value": "Un besoin, un groupe de client, une solution."
                    }, {
                        "name": "Marché-solution",
                        "value": "Un besoin, un groupe de clients, toutes les solutions."
                    }, {
                        "name": "Industrie",
                        "value": "Une solution, tout les besoins, tout les groupes de clients."
                    }, {
                        "name": "Utilité de la macro-segmentation",
                        "value": "1. Délimitation claire de son marché. \n2. Repérage de la concurrence générique. \n3. Diagnostic de dispersion et idées de nouveaux produits-marchés. \n4. Choix d’une stratégie de couverture \n5. Préparation d’une micro-segmentation"
                    }, {
                        "name": "Stratégie de couverture",
                        "value": "1. **Concentration** : se spécialiser sur un produit-marché. \n2. **Spécialiste-produit** : se spécialiser dans une fonction mais couvrir les besoins de tous les groupes d'acheteurs concernés. \n3. **Spécialiste-client** : se concentrer sur un groupe de clients mais couvrir tous leurs besoins. \n4. **Spécialisation sélective** :  se diversifier sur plusieurs produits-marchés sans lien entre eux. \n5. **Couverture complète** : offrir une gamme complète."
                    }
                ]
            },
            "Micro-segmentation" : {
                "color": "0xdba251",
                "title": "Micro-segmentation",
                "description": "La micro-segmentation permet de choisir entre standardisation et adaptation. \n**Standardisation** : gamme réduite de produits standards → coûts faible, réponse aux besoins pas optimale. \n**Adaptation** : gamme étendue de produits spécialisés → coûts élevés, réponse aux besoins optimale.",
                "fields": [{
                        "name": "Critères de micro-segmentation",
                        "value": "1. **Socio-démographique** : profil du consommateur (âge, localisation, revenus, sexe, éducation…) \n2. **Avantage recherché** : valeur du produit (qualité, durabilité, prix faible, facilité d’utilisation…) \n3. **Style de vie** : habitude globale du consommateur (taux d’occupation, valeurs…) \n4. **Comportemental** : habitudes d’achat (fréquence d’achat, utilisation du produit, fidélité…) \n5. **Occasion d’achat** : moment d’achat et façon de consommer (pour moi, pour un cadeau, pour le travail, pour chez moi…)"
                    }, {
                        "name": "Critères de segmentation réussie",
                        "value": "1. **Rentabilité** : Grand CA (en € ou en volume) et / ou petits coûts. \n2. **Réponse différentiée** : Homogénéité dans le segment et hétérogénéité des segment entre eux. \n3. **Réalisme** : segment identifiable et mesurable. \n4. **Accessibilité** : communication et distribution adaptée au segment visé"
                    }
                ]
            }
        }, 
        "Ciblage": {
            "Ciblage": {
                "color": "0xdba251",
                "title": "Ciblage",
                "description": "Le ciblage est le choix de couverture des différents segments identifiés par la micro-segmentation.",
                "fields": [{
                        "name": "Types de ciblage",
                        "value": "1. **Indifférencié** : tout le marché → pas de segmentation \n2. **Différencié complet** : tout le marché → segmentation \n3. **Différencié partiel** : pas tout le marché → segmentation. \n4. **Concentré** : pas tout le marché → un seul segment. \n5. **Marché de niche** : pas tout le marché → moins d’un segment (très peu de consommateur mais très rentable). \n6. **Sur-mesure** : tout le marché, solutions individuelles"
                    }
                ]
            }
        },
        "Attractivité": {
            "Demande primaire et demande à l'entreprise": {
                "color": "0xdba251",
                "title": "Demande primaire et demande à l'entreprise",
                "fields": [{
                        "name": "Demande primaire",
                        "value": "La demande pour l’ensemble du marché. La demande primaire est expansible quand tous utilisateurs potentiels ne sont pas encore clients."
                    }, {
                        "name": "Demande à l’entreprise",
                        "value": "La part de marché de l’entreprise."
                    }, {
                        "name": "Insuffisances qui créent un écart entre la demande primaire et le marché potentiel",
                        "value": "1. Produits-marché  : tailles, options, couleurs, qualités, goûts… \n2. Utilisation  : non-utilisateurs, utilisateurs irréguliers, quantité faible… \n3. Distribution : couverture, intensité, exposition…"
                    }, {
                        "name": "Indicateurs de l'attractivité d'un marché",
                        "value": "1. Attrait du marché : croissance, taille, cycle de vie, pouvoir d’achat… \n2. Intensité concurrentielle : nombre, force, substituts… \n3. Accessibilité du marché : barrières, technologies, médias…"
                    }
                ]
            },
            "Meta-marché": {
                "color": "0xdba251",
                "title": "Meta-marché",
                "description": "Définir un marché non pas en fonctions d’un produit-marché, mais en fonction du résultat générique recherché par les clients (ex. organisation d’un mariage : fleuriste, traiteur, location de salle…), puis proposer une solution complète au client, en complétant sont offre et/ou en s’associant avec d’autres acteurs.",
                "fields": [{
                        "name": "Avantages pour l’acheteur",
                        "value": "1. Concept aligné sur le point de vue de l’acheteur. \n2. Solution complète en un seul endroit à un problème complexe."
                    }, {
                        "name": "Avantages pour le vendeur",
                        "value": "1. Communication facile. \n2. Meilleure exclusivité, fidélité et confiance. \n3. Identification d’opportunités de développement (activités liées) donc revenu potentiel supérieur. \n4. Identification des concurrents indirects et potentiels."
                    }
                ]
            },
            "Le cycle de vie d'un produit-marché": {
                "color": "0xdba251",
                "title": "Le cycle de vie d'un produit-marché",
                "fields": [{
                        "name": "Indroduction",
                        "value": "- Risque financier élevé. \n- Demande lente et faible mais extensible. \n- Très peu de concurrence (voir monopole). \n- **Acheteurs** : innovateurs et adopteurs précoces."
                    },  {
                        "name": "Croissance",
                        "value": "- Beaucoup de nouveaux entrant \n- Demande croissante et extensible \n- Beaucoup de concurrence mais pacifique \n- **Acheteurs** : majorité précoce"
                    }, {
                        "name": "Turbulence", 
                        "value": "- Demande toujours croissante mais ralentie \n- Concurrence violente : départ des plus faible et restructuration. \n- **Acheteurs** : majorité précoce et majorité tardive"
                    }, {
                        "name": "Maturité",
                        "value": "- Forte pression sur les prix \n- Lutte pour les parts de marché \n- Concurrence stable. \n- **Acheteurs** : majorité tardive et retardataires."
                    }, {
                        "name": "Déclin",
                        "value": "- Obsolescence de la technologie ou changement d’habitude \n- Demande décroissante \n- Concurrence en déclin / disparition \n- **Acheteurs** : retardataires et spécialistes"
                    }
                ],
                "image": {
                    "url": "https://file.notion.so/f/f/3f1d15d7-392a-4d8c-938b-595bb873a21b/9a532f9b-fe23-4b87-9aff-209d7274d2ff/Capture_decran_2023-12-16_a_14.33.38.png?id=385313d2-da7f-4b47-993a-905ef8767ca1&table=block&spaceId=3f1d15d7-392a-4d8c-938b-595bb873a21b&expirationTimestamp=1706198400000&signature=6W5ge_A6LZTUpeM1kKnvx9NhTRKrVU78RK0-gsa9A6Y&downloadName=Capture+d%E2%80%99e%CC%81cran+2023-12-16+a%CC%80+14.33.38.png"
                }
            }
        }, 
        "Compétitivité": {
            "L'avantage concurrentiel externe et la différentiation": {
                "color": "0xdba251",
                "title": "L'avantage concurrentiel externe et la différentiation",
                "fields": [{
                        "name": "Avantage concurrentiel externe",
                        "value": "L'**avantage concurrentiel externe** se base sur les qualités et caractéristiques des produits reconnues par les clients de l’entreprise."
                    }, {
                        "name": "Différentiation",
                        "value": "La **différentiation** est le fait d’apporter une caractéristique unique à un produit, qui est valorisée par les clients."
                    }, {
                        "name": "Stratégie de base",
                        "value": "Différentiation"
                    },{
                        "name": "Matrice imporation / performance",
                        "value": "Permet de déterminer la réussite ou non d’une différentiation en fonctions des caractéristiques du produit."
                    }, {
                        "name": "Conditions de réussite d'une différentiation",
                        "value": "1. La valeur est apportée à l’acheteur soit par une augmentation de la performance du produit, soit par une diminution du prix. \n2. La différentiation doit porter sur une caractéristique importante pour le client. \n3. Le supplément de prix doit trouver une justification ****aux yeux du client. \n4. Supplément de prix >  supplément de coût causé. \n5. La différenciation doit être défendable : à l’abri des imitations. \n6. Il faut faire connaître les éléments d’unicité."
                    }
                ]
            }, 
            "L'avantage concurrentiel interne et l'effet d'expérience": {
                "color": "0xdba251",
                "title": "L'avantage concurrentiel interne et l'effet d'expérience",
                "fields": [{
                        "name": "Avantage concurrentiel interne",
                        "value": "L’**avantage concurrentiel interne** se base sur la productivité et les coût faibles de l’entreprise."
                    }, {
                        "name": "L'effet d'expérience",
                        "value": "L’**effet d’expérience** est le fait que plus on augmente la production, plus les coûts unitaires diminuent (amélioration et automatisation des processus, formations de travailleurs…). Adopter un prix de pénétration permet de vendre plus au début et donc d’accroître très rapidement son effet d’expérience."
                    }, {
                        "name": "Stratégie de base",
                        "value": "Domination par les coûts"
                    }
                ],
                "image": {
                    "url": "https://file.notion.so/f/f/3f1d15d7-392a-4d8c-938b-595bb873a21b/15d54a21-6102-450e-8d31-20c4c220f051/Capture_decran_2023-12-16_a_10.31.29.png?id=ab5cc498-7330-484c-9204-7990541ea0b4&table=block&spaceId=3f1d15d7-392a-4d8c-938b-595bb873a21b&expirationTimestamp=1706212800000&signature=Dpg4wIiWiH8DcPSOwcQeTf-XaRffr8in5e0XPKBLvLw&downloadName=Capture+d%E2%80%99e%CC%81cran+2023-12-16+a%CC%80+10.31.29.png"
                }
            },
            "Les situations concurrentielles": {
                "color": "0xdba251",
                "title": "Les situations concurrentielles",
                "fields": [{
                        "name": "Concurrence parfaite",
                        "value": "- Grand nombre de fabricants et d’acheteurs. \n- Produits parfaitement substituables. \n- Prix déterminés par le jeu de l’offre et de la demande. \n- Absence de pouvoir de marché pour l’entreprise. \n- **Objectif** : Sortir de l’anonymat de la concurrence pure par la différenciation et la segmentation."
                    }, {
                        "name": "Concurrence monopolistique",
                        "value": "- Grand nombre de fabricants et d’acheteurs \n- Produits ayant des qualités distinctives valorisées par les clients \n- Le capital de marque (ou d’entreprise) donne un pouvoir de marché limité. \n **Objectif** : Protéger et valoriser l’élément de différenciation."
                    }, {
                        "name": "Monopole",
                        "value": "- Un seul fabricant sans concurrent direct \n- Monopole de l’innovateur limité dans le temps (introduction du CVP) \n- **Objectif** : Protéger (ou copier selon la position)"
                    }, {
                        "name": "Oligopole",
                        "value": "- Petit nombre de concurrents \n- Marché stagnant ou en croissance faible \n- **Oligopole indifférencié** : les produits sont substituables \n- **Oligopole différencié** : les produits ont des caractéristiques distinctives valorisées par les clients \n- L’interdépendance entre concurrents neutralise le pouvoir de marché \n- **Objectif** : Sortir de l’anonymat de la concurrence pure par la différenciation et la segmentation."
                    }
                ]
            }
        },
        "Stratégies" : {
            "La matrice BCG": {
                "color": "0xdba251",
                "title": "La matrice BCG",
                "fields": [{
                        "name": "Vedette",
                        "value": "- Leader sur un marché croissant \n- Grand besoin de liquidité \n- **Décision financière** :  Investir pour défendre la croissance. \n- **Décision stratégique** : Développer les opportunités de croissance."
                    }, {
                        "name": "Enfants à problèmes",
                        "value": "- Suiveur sur un marché croissant \n- **Décision financière** : Investir pour augment les PDM ou désinvestir. \n- **Décision stratégique** : attaquer les concurrents ou cibler une niche ou quitter."
                    }, {
                        "name": "Vache à lait",
                        "value": "- Leader sur un marché mature \n- Sources de liquidités \n- **Décision financière** :  Ne pas investir trop sur le produit et utiliser les liquidités sur des nouveaux produits. \n- **Décision stratégique** : Récolter les liquidité et protéger la position de force."
                    }, {
                        "name": "Poids morts",
                        "value": "- Suiveur sur un marché mature \n- Rapporte peu \n- **Décision financière**: Se maintenir en adoptant un profil bas ou désinvestir. \n- **Décision stratégique** : Adopter une stratégie de niche ou récolter et extraire un cash flow maximum."
                    }
                ]
            },
            "Les stratégies de croissance": {
                "color": "0xdba251",
                "title": "Les stratégies de croissance",
                "fields": [{
                        "name": "Croissance intensive",
                        "value": "Croître au sein du marché de référence. \n1. **Pénétration de marché** : stimuler la demande primaire et augmenter ses parts de marché \n2. **Croissance par les marchés** : nouveaux segments, expansion géographique et augmentation distribution \n3. **Croissance par les produit** : extension de gamme, amélioration des produits et rajeunissement des anciens produits \n 4. **Diversification** : concentrique -> complémentaire à ce qu’on faisait avant (même savoir faire…) (Nutella) ou pure -> autre domaine (Virgin : Radio, Casinos…)"
                    }, {
                        "name": "Croissance intégrative",
                        "value": "On rachète des entreprises (donne plus de pouvoir sur l’industrie) : \n1. **Intégration en amont** : racheter des fournisseurs. \n2. **Intégration en aval** : racheter des distributeurs. \n3. **Intégration horizontale** : racheter des concurrents."
                    }
                ]
            },
            "Les stratégies conurrenctielles": {
                "color": "0xdba251",
                "title": "Les stratégies cocurrentielles",
                "fields": [{
                        "name": "Leader (domine en PDM)",
                        "value": "1. **Offensif** : Maximiser ses parts de marché → industrie de volume \n2. **Défensif** : Garder ses parts de marché → innovation, gamme, pub \n3. **Recul volontaire** : Réduire sa taille pour éviter le monopole"
                    }, {
                        "name": "Challenger (deuxième en PDM)",
                        "value": "→ But : surpasser le leader \n1. **Attaque frontale** : substitut direct au leader (même attributs, même forces) \n2. **Attaque latérale** : on s’attaque au point faible du leaderc \n3. **Acquisition** : augmenter sa taille en rachetant des concurrents"
                    }, {
                        "name": "Suiveur",
                        "value": "Coexister avec les autres acteurs de manière pacifique mais créative. \n→ Créativité, segmentation, amélioration des coûts, R&D, rester à petite échelle"
                    }, {
                        "name": "Spécialiste",
                        "value": "Coexister avec les autres acteurs de manière pacifique mais créative. \n→ Créativité, segmentation, amélioration des coûts, R&D, rester à petite échelle"
                    }
                ]
            }
        }
    },
    "firstaid": {
        "Concepts de base": {
            "Contacter les secours": {
                "color": "0xff0000",
                "title": "Contacter les secours",
                "description": "Pour contactet les secours il faut suivre la règle \"Où, Qui, Quoi\" pour donner les informations nécessaires aux secours.",
                "fields": [{
                        "name": "Où",
                        "value": "Donner l'adresse précise de l'endroit où se trouve la victime (ville, rue, numéro de rue, étage, appartement...). On commence par l'endroit de l'urgence comme ça si l'appel est coupé, les secours peuvent quand même se rendre sur place."
                    }, {
                        "name": "Qui",
                        "value": "Dites qui vous êtes (Nom et prénom)."
                    }, {
                        "name": "Quoi",
                        "value": "Donner les informations sur l'accident. Ce qui s'est passé, le nombre de victimes et l'état des victimes, leur âge... et répondez aux questions des secours. Ils resteront en ligne avec vous pour vous guider et vous donner des conseils tant que c'est nécessaire."
                    }
                ]
            }
        }
    },
    "calculability": {
        "Théorèmes": {
            "Théorème de Cantor": {
                "color": "0x325ca8",
                "title": "Théorème de Cantor",
                "description": "Le théorème de Cantor est un théorème de la théorie des ensembles qui énonce que pour tout ensemble E, il n'existe pas de bijection entre E et l'ensemble de ses parties.",
                "fields": [{
                        "name": "Formulation",
                        "value": "Pour tout ensemble E, il n'existe pas de bijection entre E et l'ensemble de ses parties."
                    }
                ]
            },
            "Théorème de Hoare-Allison": {
                "color": "0x325ca8",
                "title": "Théorème de Hoare-Allison",
                "description": "Le théorème de Hoare-Allison est un théorème de la théorie des ensembles qui énonce que pour tout ensemble E, il existe une bijection entre E et l'ensemble de ses parties.",
                "fields": [{
                        "name": "Formulation",
                        "value": "Pour tout ensemble E, il existe une bijection entre E et l'ensemble de ses parties."
                    }
                ]
            },
            "Théorème de Rice": {
                "color": "0x325ca8",
                "title": "Théorème de Rice",
                "description": "Le théorème de Rice est un théorème de la théorie de la calculabilité qui énonce que pour toute propriété non triviale des fonctions calculables, il est impossible de déterminer algorithmiquement si une machine de Turing donnée calcule une fonction ayant cette propriété.",
                "fields": [{
                        "name": "Formulation",
                        "value": "Soit P une propriété non triviale des fonctions calculables. Alors il est impossible de déterminer algorithmiquement si une machine de Turing donnée calcule une fonction ayant cette propriété."
                    }
                ]
            },
            "Théorème de l'arret (HALT)": {
                "color": "0x325ca8",
                "title": "Théorème de l'arrêt (HALT)",
                "description": "Une fonction disant si un programme s’arrête ou non n’est pas calculable.",
                "fields": [{
                        "name": "Démonstration",
                        "value": ""
                    }
                ]
            },
            "Théorème du point fixe": {
                "color": "0x325ca8",
                "title": "Théorème du point fixe",
                "description": "Le théorème du point fixe est un théorème de la théorie des ensembles qui énonce que pour toute fonction f définie sur un ensemble E, s'il existe un élément x de E tel que f(x) = x, alors x est un point fixe de f.",
                "fields": [{
                        "name": "Formulation",
                        "value": "Soit f une fonction définie sur un ensemble E. Si f admet un point fixe x, alors x est un point fixe de f."
                    }
                ]
            }
        }
    }
}