{
    "algebra": {
        "Matrices": {
            "Matrice échelonée": {
                "color": "0x3b8bc4",
                "title": "Matrice échelonée",
                "description": "Une matrice est dite échelonnée si le nombre de zéros précédant la première valeur non nulle d'une ligne augmente strictement ligne par ligne jusqu'à ce qu'il ne reste éventuellement plus que des zéros.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```0 | 1 | 2 | 3 | 4\n0 | 0 | 5 | 8 | 7\n0 | 0 | 0 | 9 | 10\n0 | 0 | 0 | 0 | 0\n0 | 0 | 0 | 0 | 0```"
                    }
                ]
            }, 
            "Forme réduite de gauss-jordan": {
                "color": "0x3b8bc4",
                "title": "Forme réduite de Gauss-Jordan",
                "description": "Une matrice est dite en forme réduite de Gauss-Jordan si elle est échelonnée et si toutes les valeurs non nulles sont égales à 1.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```1 | 0 | 0 | 0 | 0\n0 | 1 | 0 | 0 | 0\n0 | 0 | 1 | 0 | 0\n0 | 0 | 0 | 1 | 0\n0 | 0 | 0 | 0 | 1```"
                    }
                ]
            },
            "Matrice carrée": {
                "color": "0x3b8bc4",
                "title": "Matrice carrée",
                "description": "Une matrice est dite carrée si elle possède le même nombre de lignes et de colonnes.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```0 | 1 | 2\n3 | 4 | 5\n6 | 7 | 8```"
                    }
                ]
            },
            "Produit matriciel": {
                "color": "0x3b8bc4",
                "title": "Produit matriciel",
                "description": "Le produit matriciel de deux matrices `A` et `B` est une matrice `C` telle que `C = AB`.",
                "fields": [{
                        "name": "Condition de résolution",
                        "value": "Le nombre de colonnes de la première matrice doit être égal au nombre de lignes de la deuxième matrice. \nSi `A` est une matrice de dimention `m x n` et `B` une matrice `n x k`, alors il est possible de réaliser le produit `AB` mais pas le produit `BA`."
                    }, {
                        "name": "Methode de résolution",
                        "value": "Pour chaque élément de la matrice résultat, on calcule la somme des produits des éléments de la ligne de la première matrice et de la colonne de la deuxième matrice. \nPour rendre cela plus facile on peut placer les matrices du produit de manière à ce que la matrice résultat se trouve à droite de la première matrice et en dessous de la seconde."
                    }, {
                        "name": "Exemple",
                        "value": "```          b  |  b  |  b \n          b  |  b  |  b\na | a    2ab | 2ab | 2ab  \na | a    2ab | 2ab | 2ab```"
                    }
                ]
            }
        }
    },
    "algorithmics": {
        "Général": {
            "Définition d'un algorithme": {
                "color": "0xebc034",
                "title": "Définition d'un algorithme",
                "description": "Un algorithme est l’idée derrière un programme. C’est une suite finie d’opérations élémentaires qui permet de résoudre un problème donné. \n- Un algorithme est indépendant du langage de programmation, du système d’exploitation et de la machine sur laquelle s’exécute le programme qui implémente l’algorithme. \n- Pour certains problèmes (même très courants et simples à énoncer), iln’existe pas d’algorithme exact et efficace. \n- Pour d’autres problèmes, il existe plusieurs algorithmes exacts (certains sont plus efficaces que d’autres).",
                "fields": [{
                        "name": "Propriétés d'un algorithme",
                        "value": "- Avoir une portée suffisamment large. \n- Etre exact : un algorithme doit donner le résultat exact attendu. \n- Etre fini : un algorithme doit se terminer après un nombre fini d’étapes. \n- Etre efficace : il doit se terminer en un temps raisonnable et utiliser une quantité raisonnable de mémoire."
                    }
                ]
            }
        },
        "Complexité caluclatoire": {
            "Complexité temporelle": {
                "color": "0xebc034",
                "title": "Complexité temporelle",
                "description": "La complexité temporelle d’un algorithme, notée `T(n)`,  représente le nombre d’opérations primitives effectuées par l’algorithme pour résoudre un problème de taille `n`. \nCette donnée est importante car si on connait le temps nécessaire pour une opération primitive, elle permet de déterminer la taille maximale du problème que l'on peut traiter sur un intervalle de temps donné."
            },
            "Complexité spaciale": {
                "color": "0xebc034",
                "title": "Complexité spaciale",
                "description": "La complexité spatiale d’un algorithme, notée `S(n)`, représente la quantité de mémoire utilisée par l’algorithme pour résoudre un problème de taille `n`. \nCette donnée est importante car si on connait la quantité de mémoire disponible, elle permet de déterminer la taille maximale du problème que l'on peut traiter."
            }
        },
        "Types Abstraits de Données": {
            "Généralités": {
                "color": "0x3b8bc4",
                "title": "Types abstraits de données",
                "description": "Un type abstrait de données (TAD) est une spécification abstraite d’une structure de données qui décrit : \n1. Ce qui peut être mémorisé dans le TAD, mais pas comment cette information est mémorisée (organisation dans la mémoire). \n2. Quelles opérations peuvent être effectuées sur le TAD, mais pas comment ces opérations doivent être effectuées. \n\nUne structure de données : une organisation particulière des données d’un programme (int, str, list…)"
            },
            "TAD Pile": {
                "color": "0x3b8bc4",
                "title": "Pile",
                "description": "Une pile (Stack) est une collection d’éléments qui peuvent être ajoutés ou retirés selon le principe LIFO (Last In First Out) : \n- Le premier objet à pouvoir être retiré (*pop*) est le dernier qui a été inséré (*push*). \n- On ne peut pas retirer d’objet si la pile est vide.",
                "fields": [{
                        "name": "Analogie",
                        "value": "Une pile d’assiettes."
                    }, {
                        "name": "Opérations principales",
                        "value": "- `push(e)` : ajoute l'élément `e` au sommet de la pile. \n- `pop()` : retire et renvoie l’élément au sommet de la pile. \n- `is_empty()` : renvoie `True` si la pile est vide, `False` sinon."
                    }, {
                        "name": "Méthodes d'implémentation",
                        "value": "- Listes chaînées \n- Tableaux dynamiques"
                    }, {
                        "name": "Exemple",
                        "value": "```py\npile = Stack() \npile.push(1) \npile.push(2) \n\nprint(pile.pop())\n>>> 2\nprint(pile.pop()) \n>>> 1```"
                    }
                ]
            },
            "TAD File": {
                "color": "0x3b8bc4",
                "title": "File",
                "description": "Une file (Queue) est une collection d’éléments qui peuvent être ajoutés ou retirés selon le principe FIFO (First In First Out) : \n- Le premier objet à pouvoir être retiré est le plus ancien à avoir été inséré et qui n’a pas encore été retiré. \n- On ne peut retirer aucun objet si la file est vide.",
                "fields": [{
                        "name": "Analogie",
                        "value": "Une file d’attente."
                    }, {
                        "name": "Opérations principales",
                        "value": "- `enqueue(e)` : ajoute l'élément `e` à la fin de la file. \n- `dequeue()` : retire et renvoie l’élément au début de la file. \n- `is_empty()` : renvoie `True` si la file est vide, `False` sinon."
                    }, {
                        "name": "Méthodes d'implémentation",
                        "value": "- Listes chaînées \n- Tableaux dynamiques circulaires"
                    }, {
                        "name": "Exemple",
                        "value": "```py\nfile = Queue() \nfile.enqueue(1) \nfile.enqueue(2) \n\nprint(file.dequeue())\n>>> 1\nprint(file.dequeue()) \n>>> 2```"
                    }
                ]
            },
            "TAD Liste": {
                "color": "0x3b8bc4",
                "title": "Liste",
                "description": "Une Liste est un TAD qui décrit une collection d’éléments auxquels on accède via les méthodes `head()` (le premier élément) et `tail()` (une sous-liste). \n\nCe TAD à une implémentation récursive. Pour accéder à un élément spécifique dans la liste, on va utiliser une fonction dont le cas de base est une liste vide et l’appel récursif éventuel se fait sur la sous-liste.",
                "fields": [{
                        "name": "Exemple",
                        "value": "```py\nl = List() # creation d'une liste vide \nl = l.concat(1) # ajoute 1 en tête de la liste \nl = l.concat(2) # ajoute 2 en tête de la liste \nprint(l.head()) \n>>> 2 \nprint(l) \n>>> \"[2[1[]]]\" \nprint(l.tail()) \n>>> \"[1[]]\"```"
                    }
                ]
            },
            "TAD Dictionnaire": {
                "color": "0x3b8bc4",
                "title": "Dictionnaire",
                "description": "Le TAD dictionnaire est une collection d’entrées pour laquelle on accède à chaque entrée par une clé. Il contient donc des couples (clé, valeur).",
                "fields": [{
                        "name": "Propriété additionnelle possibles",
                        "value": "- **Clés multiples** : plusieurs entrées sont référencées par la même clé \n- **Ordonné** : un ordre est défini sur les clés."
                    }
                ]
            },
            "TAD Arbre": {
                "color": "0x3b8bc4",
                "title": "Arbre",
                "description": "Le TAD arbre permet de représenter une structure hiérarchique (table des matières, système de fichiers…). C’est un type abstrait récursif composé de différents noeuds (il peut aussi être vide). Un noeud se trouve à la racine et les autres dans les sous-arbres. \n\nUn arbre est binaire si pour chaque noeud il y a au maximum deux sous arbres (gauche et droit).",
                "fields": [{
                        "name": "Exemple",
                        "value": "```      a       \n    /   \\    \n   b     c   \n  / \\   / \\ \n d   e f   g\n```"
                    }
                ]
            }
        },
        "Arbre Binaire de Recherche": {
            "Généralités": {
                "color": "0xf0a573",
                "title": "Arbres binaires de recherche",
                "description": "Un arbre binaire de recherche (ABR) est une implémentation d’un TAD dictionnaire dans sous forme d’arbre binaire. Dans un ABR, pour chaque noeud, l’élément qui se trouve à gauche de celui-ci doit-être plus petit et l’élément à droite doit être plus grand."
            }, 
            "Parcours": {
                "color": "0xf0a573",
                "title": "Parcours d'un ABR",
                "description": "Il y a trois opérations possible dans un ABR : l’insertion, la suppression ou la recherche d’une clé. \nPour effectuer ces actions, il est nécessaire de parcourir l’arbre. Il existe différentes manière de parcourir un ABR, toutes sont récursives.",
                "fields": [{
                        "name": "Parcours infixe",
                        "value": "On parcourt l’arbre en commençant par le sous-arbre gauche, puis la racine et enfin le sous-arbre droit."
                    }, {
                        "name": "Parcours préfixe",
                        "value": "On parcourt l’arbre en commençant par la racine, puis le sous-arbre gauche et enfin le sous-arbre droit."
                    }, {
                        "name": "Parcours postfixe",
                        "value": "On parcourt l’arbre en commençant par le sous-arbre gauche, puis le sous-arbre droit et enfin la racine."
                    }, {
                        "name": "Exemple",
                        "value": "```       0       \n     /   \\    \n   -3     6   \n   / \\   / \\ \n -7  -1 4   9\n``` \nParcours infixe: ```-7 -3 -1 0 4 6 9``` \nParcours préfixe: ```0 -3 -7 -1 6 4 9``` \nParcours postfixe: ```-7 -1 -3 4 9 6 0```"
                    }
                ]
            },
            "Opérations": {
                "color": "0xf0a573",
                "title": "Opérations sur un ABR",
                "fields": [{
                    "name": "Insertion d'une clé",
                    "value": "Pour insérer une clé dans l’ABR, on va parcourir l’arbre par la méthode préfixe, jusqu’à se qu’on se trouve à un endroit ou le noeud de gauche est plus petit ou égal à la clé et le noeud de droite plus grand. On doit alors insérer cette clé dans l’arbre par la même méthode que pour l’insertion dans une liste chaînée."
                }, {
                    "name": "Recherche d'une clé",
                    "value": "La recherche d’une clé dans un ABR dépend de sa hauteur `h`, et celle si dépend de si l’arbre est équilibré ou non. \n- Arbre équilibré : `h ∈ Θ(log_2 n)` → Recherche en `O(log_2 n)` (meilleur cas `Θ(1)`, pire cas $Θ(log_2 n)$). \n- Arbre déséquilibré : `h ∈ Θ(n)` → Recherche en `O(n)` (meilleur cas `Θ(1)`, pire cas `Θ(n)`)."
                }, {
                    "name": "Suppression d'une clé",
                    "value": "Pour la suppression d’une clé on va d’abords rechercher cette clé dans l’arbre. Une fois trouvée, on la supprime en suivant une méthode analogue aux listes chaînées mais il faut aussi faire attention de remonter les clés appartenant aux sous-arbres de la clé qu’on supprime qui ne seraient plus dans l’ordre."
                }]
            },
            "Implémentation": {
                "color": "0xf0a573",
                "title": "Implémentation d'un ABR",
                "description": "Un ABR peut être implémenté de deux manières différentes : \n\n**Liste chaînée** \nChaque noeud est représenté par un objet contenant la clé, la valeur et les sous-arbres gauche et droit. \n- Accès à n’importe quel noeud à partir de la racine en `O(n)`. \n- Complexité spatiale en `Θ(n)`. \n\n**Tableau dynamique** \nChaque noeud est représenté par un objet contenant la clé, la valeur et l’indice des sous-arbres gauche et droit dans le tableau. \n- Accès à n’importe quel noeud en `Θ(1)` par un calcul d’indice dans le tableau. \n- La complexité spatiale peut être exponentielle dans le pire cas : `O(2^n)`, où `n` est le nombre de noeuds présents dans l’arbre. Si l’arbre est strictement complet, c’est-à-dire si tous les niveaux sont remplis, alors la complexité spatiale est en `Θ(n)`."
            }
        },
        "Algorithmes de tri": {
            "Tri à bulles": {
                "color": "0xd573f0",
                "title": "Tri à bulles",
                "description": "Inverser toute paire d’éléments adjacents qui sont désordonnés. Un plus grand élément est comme une bulle remontant vers la fin, et un plus petit élément une bulle descendant vers le début.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n^2)` \n    - `Theta(n^2)` comparaisons \n     - `O(n^2)` échanges \n- Stable \n- En place : espace additionnel `Theta(1)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef bubble_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(len(l) - 1, 0, -1): \n        for j in range(1, i+1): \n            if l[j-1] > l[j]: \n                l[j-1], l[j] = l[j], l[j-1] \n    return l\n```"
                }, {
                    "name": "Variante pour le rendre adaptatif",
                    "value": "On ajoute une vérification qui coupe la boucle si il n’y a pas eu d’échange lors de cette itération (et donc que la liste est déjà triée). \n- Complexité temporelle globale : `O(n^2)` \n- `O(n^2)` comparaisons \n- `O(n^2)` échanges"
                }, {
                    "name": "Code",
                    "value": "```py\ndef bubble_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(len(l) - 1, 0, -1): \n        swap = False \n        for j in range(1, i+1): \n            if l[j-1] > l[j]: \n                l[j-1], l[j] = l[j], l[j-1] \n                swap = True \n        if not swap: \n            break \n    return l\n```"
                }]
            },
            "Tri par sélection": {
                "color": "0xd573f0",
                "title": "Tri par sélection",
                "description": "Sélectionner de façon répétée le plus petit élément restant et le mettre au début.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n^2)` \n    - `Theta(n^2)` comparaisons \n    - `Theta(n)` échanges → marginalement interessant si on veut minimiser les échanges. Ò\n- En place : espace additionnel `Theta(1)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef selection_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(len(l)): \n        min_index = i \n        for j in range(i+1, len(l)): \n            if l[min_index] > l[j]: \n                min_index = j \n        l[i], l[min_index] = l[min_index], l[i] \n    return l\n```"
                }]
            },
            "Tri par insertion": {
                "color": "0xd573f0",
                "title": "Tri par insertion",
                "description": "Insérer de façon répétée chaque élément dans la partie déjà triée de la liste.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `O(n^2)` \n    - `O(n^2)` comparaisons \n    - `O(n^2)` échanges \n- Stable \n- En place : espace additionnel `Theta(1)` \n- Adaptatif"
                }, {
                    "name": "Code",
                    "value": "```py\ndef insertion_sort(l: list): \n    \"\"\"\n    Retourne la liste `l` triée par ordre croissant.\n    \"\"\"\n    for i in range(1, len(l)): \n        j = i \n        while j > 0 and l[j-1] > l[j]: \n            l[j-1], l[j] = l[j], l[j-1] \n            j -= 1 \n    return l\n```"
                }]
            },
            "Tri fusion": {
                "color": "0xd573f0",
                "title": "Tri fusion",
                "description": "Diviser la liste en deux sous-listes de taille égale, trier chacune des sous-listes, puis fusionner les deux sous-listes triées en une seule liste triée. La première étape est récursive, le cas de base étant une liste de taille 0 ou 1 -> forcément triée.",
                "fields": [{
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n log n)` \n- Stable \n- En place : espace additionnel `Theta(n)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef merge_sort(l: list) -> list: \n    \"\"\" \n    Retourne la liste `l` triée par ordre croissant. \n    \"\"\"\n    def merge(l1: list, l2:list) -> list:\n        \"\"\" \n        Fusionne deux sous tableaux `l1` et `l2` triés.\n        \"\"\"\n        res = []\n        while len(l1) != 0 and len(l2) != 0:\n            if l1[0] <= l2[0]:\n                res.append(l1[0])\n                l1.pop(0)\n            else:\n                res.append(l2[0])\n                l2.pop(0)\n        while len(l1) != 0:\n            res.append(l1[0])\n            l1.pop(0)\n        while len(l2) != 0:\n            res.append(l2[0])\n            l2.pop(0)\n        return res\n    n = len(l)\n    if n == 1:\n        return l\n    return merge(merge_sort(l[:n//2]), merge_sort(l[n//2:]))\n```"
                }]
            },
            "Tri linéaire": {
                "color": "0xd573f0",
                "title": "Tri linéaire",
                "description": "Le tri linéaire est un tri qui s’effectue en temps linéaire. Il est possible de trier une liste en temps linéaire si on sait que les éléments de la liste sont des entiers compris entre 0 et `n` (ou `n-1`).",
                "fields": [{
                    "name": "Principe",
                    "value": "On va créer une liste de taille `n` remplie de 0. On va ensuite parcourir la liste à trier et incrémenter la valeur de la liste aux indices correspondant aux valeurs de la liste à trier. On va ensuite parcourir la liste de comptage et ajouter à la liste à trier autant de fois la valeur de l’indice que la valeur de l’indice. \n\nExemple : \n\n`[2, 5, 3, 0, 2, 3, 0, 3]` \n\n`[2, 0, 2, 1, 0, 1, 3, 0, 0, 0]` \n\n`[0, 0, 2, 2, 3, 3, 3, 5]`"
                }, {
                    "name": "Propriétés",
                    "value": "- Complexité temporelle globale : `Theta(n)` \n- Stable \n- En place : espace additionnel `Theta(n)`"
                }, {
                    "name": "Code",
                    "value": "```py\ndef counting_sort(l: list) -> list: \n    \"\"\" \n    Retourne la liste `l` triée par ordre croissant. \n    \"\"\"\n    n = len(l)\n    res = [0] * n\n    for i in range(n):\n        res[l[i]] += 1\n    j = 0\n    for i in range(n):\n        while res[i] != 0:\n            l[j] = i\n            j += 1\n            res[i] -= 1\n    return l\n```"
                }]
            }
        }
    },
    "electronics": {
        "Fonctions booléennes": {
            "Not": {
                "color": "0x5834eb",
                "title": "Not",
                "description": "La porte logique **NOT** retourne l'inverse de son entrée.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nin | out\n0  | 1\n1  | 0\n```"
                    }
                ],
                "thumbnail": { 
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097089814840496188/not.png"
                }
            },
            "And": {
                "color": "0x5834eb",
                "title": "And",
                "description": "La porte logique **AND** retourne 1 si les deux entrées sont à 1, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097117357576568883/and.png"
                }
            },
            "Or": {
                "color": "0x5834eb",
                "title": "Or",
                "description": "La porte logique **OR** retourne 1 si au moins une des deux entrées est à 1, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097266856865321080/or.png"
                }
            },
            "Nand": {
                "color": "0x5834eb",
                "title": "Nand",
                "description": "La porte logique **NAND** retourne 1 si au moins une des deux entrées est à 0, et 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267029477707816/nand.png"
                }
            },
            "Nor": {
                "color": "0x5834eb",
                "title": "Nor",
                "description": "La porte logique **NOR** retourne 1 si les deux entrées sont 0, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267140735815771/nor.png"
                }
            },
            "Xor": {
                "color": "0x5834eb",
                "title": "Xor",
                "description": "La porte logique **XOR** retourne 1 si les deux entrées sont différentes, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 0\n0 | 1 | 1\n1 | 0 | 1\n1 | 1 | 0\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267300492640256/xor.png"
                }
            },
            "Xnor": {
                "color": "0x5834eb",
                "title": "Xnor",
                "description": "La porte logique **XNOR** retourne 1 si les deux entrées sont identiques, 0 sinon.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | out\n0 | 0 | 1\n0 | 1 | 0\n1 | 0 | 0\n1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097089814840496188/xnor.png"
                }
            },
            "Mux": {
                "color": "0x5834eb",
                "title": "Mux",
                "description": "La porte logique **MUX** (Multiplexer) permet de choisir entre deux entrées selon la valeur d'une troisième entrée (sel).",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nA | B | sel | out\n0 | 0 | 0 | 0\n0 | 0 | 1 | 0\n0 | 1 | 0 | 0\n0 | 1 | 1 | 1\n1 | 0 | 0 | 1\n1 | 0 | 1 | 0\n1 | 1 | 0 | 1\n1 | 1 | 1 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267398266073168/mux.png"
                }
            },
            "Dmux": {
                "color": "0x5834eb",
                "title": "Dmux",
                "description": "La porte logique **DMUX** (Demultiplexer) retourne les valeurs de A et B selon la valeur de in et sel.",
                "fields": [
                    {
                        "name": "Table de vérité",
                        "value": "```\nin | sel | A | B\n0 | 0 | 0 | 0\n0 | 1 | 0 | 0\n1 | 0 | 1 | 0\n1 | 1 | 0 | 1\n```"
                    }
                ],
                "thumbnail": {
                    "url": "https://cdn.discordapp.com/attachments/1097089532601565296/1097267480638005371/dmux.png"
                }
            }
        },
        "Language d'assemblage": {
            "Instructions de type A": {
                "color": "0xd99241",
                "title": "Instructions de type A",
                "description": "Les instructions de type A (A = adresse) permettent de charger des information de 15 bits (avec le bits de poid fort mit à 0 pour faire 16 bits en tout) dans le registre A. Elles permetent aussi d’accéder à l’information qui se trouve en mémoire à l’adresse spécifiée dans le registre A.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@12 // Charge la valeur 12 dans A et permet d'accéder là l'information contenue dans la mémoire à l'adresse 12.\n```"
                    }
                ]
            },
            "Instructions de type C": {
                "color": "0xd99241",
                "title": "Instructions de type C",
                "description": "Les instructions de type C (C = calculer) permettent d’effectuer toutes les autres opérations permisent par l’ALU. Elles ont donc plusieurs fonctionalités différentes. Il y a deux sortes d’instructions  différentes : Les instructions d’accès et @."
            },
            "Saut non-conditionel": {
                "color": "0xd99241",
                "title": "Saut non-conditionel",
                "description": "L’instruction **0;JMP**© permet de faire un saut non-conditionel (sera toujours effectué si l’instruction est lue) vers l’adresse indiquée.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n(DEBUT) // Début de la boucle\n@x\nM=M+1 // Ajoute 1 à la valeur de x\n0;JMP // Saut vers le début de la boucle\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\nwhile True:\n    x += 1\n```"
                    }
                ]
            },
            "Saut conditionel": {
                "color": "0xd99241",
                "title": "Saut conditionel",
                "description": "Il existe plusieurs instructions qui permettent d’effectuer un saut seulement si la condition attendue est respectée. La condition peut être imposée sur n’importe quelle variable exitante. Dans les exemple ci-dessus c’est le registre `D` qui est utilisé :\n\n1. `D;JEQ` (Jump if EQual to 0) → Saute si la variable vaut 0. (`D == 0`)\n2. `D;JNE` (Jump if Not Equal to 0) → Saute si la variable est différente de 0. (`D != 0`)\n3. `D;JGT` (Jump if Greater Than 0) → Saute si la variable est strictement positive. (`D > 0`)\n4. `D;JLT` (Jump if Lower Than 0) → Saute si la variable est strictement négative. (`D < 0`)\n5. `D;JGE` (Jump if Greater than or Equal to 0) → Saute si la variable est positive. (`D >= 0`)\n6. `D;JLE` (Jump if Lower than or Equal to 0) → Saute si la variable est négative. (`D <= 0`)",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@x\nD=M // Assigne la valeur de x à D\n\n@COND\nD;JGT // Saute si x > 0\n@x\nM=1 // Assigne la valeur 1 à x\n@FIN\n0;JMP // Saute à le fin pour ne pas effectuer le rest du code\n(COND)\n\n@x\nM=-1 // Assigne la valeur -1 à x\n(FIN)\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nif x > 0:\n    x = 1\nelse:\n    x = -1\n```"
                    }
                ]
            },
            "Boucles": {
                "color": "0xd99241",
                "title": "Boucles",
                "description": "Les boucles peuvent être implémentée en utilisant des instruction de saut.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n@x\nM=1 // Assigne la valeur 1 à x\n@n\nM=1 // Assigne la valeur 1 à n\n\n(DBOUCLE) // Début de la boucle\n@10\nD=A // Assigne la valeur 10 à D\n@n\nD=M-D // Assigne la valeur de (n - 10) à D -> Si n >= 10 (inverse de la condition de la boucle), D >= 0\n@FBOUCLE\nD;JGE // Saute vers la fin si D >= 0 (condition de la boucle n'est plus respectée)\n@x\nD=M // Assigne la valeur de x à D\n@x\nM=D+M // Assigne la valeur de (x + x) à x\n@n\nM=M+1 // Ajoute 1 à la valeur de n\n@DBOUCLE\n0;JMP // Saute vers le début de la boucle\n(FBOUCLE) // Fin de la boucle\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 1\nn = 1\nwhile n < 10:\n    x += x\n    n += 1\n```"
                    }
                ]
            },
            "Break": {
                "color": "0xd99241",
                "title": "Break",
                "description": "Il possible d’impléménter l’instuction `break` grâce aux sauts, en language assembleur.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n// Assigne la valeur 0 à x\n@x\nM=0\n\n// Assigne la valeur 0 à y\n@y\nM=0\n\n(DBOUCLE)\n// Saute vers la fin si x != 0\n@x\nD=M\n@FBOUCLE\nD;JNE\n\n// Ajoute 1 à la valeur de y\n@y\nM=M+1\n\n// Saute vers le début si y != 2\n@2\nD=A\n@y\nD=M-D // y-2 -> si y != 2, D != 0\n@DBOUCLE\nD;DNE\n\n// Termine la boucle si y == 2 -> break\n@FBOUCLE\n0;JMP\n(FBOUCLE)\n```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\ny = 0\nwhile x==0: # sera toujours vrai\n    y += 1\n    if y == 2:\n        break # y vaudra 2 à la fin\n```"
                    }
                ]
            },
            "Continue": {
                "color": "0xd99241",
                "title": "Continue",
                "description": "Il possible d’impléménter l’instuction `continue` grâce aux sauts, en language assembleur.",
                "fields": [
                    {
                        "name": "Exemple",
                        "value": "```as\n// Assigne la valeur 0 à x\n@x\nM=0\n\n(DBOUCLE)\n// Retourne au début de la boucle -> continue\n@DBOUCLE\n0;JMP\n\n// Ajoute 1 à la valeur de x\n@x\nM=M+1```"
                    },
                    {
                        "name": "Code python correspondant",
                        "value": "```py\nx = 0\nwhile True:\n   continue # La boucle infie va continuer sans rien faire\n   x += 1 # Cette ligne ne sera jamais lue\n```"
                    }
                ]
            }
        }
    }
}